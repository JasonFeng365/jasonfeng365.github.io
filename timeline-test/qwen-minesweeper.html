<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Minesweeper Test</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .cell {
            width: 3rem;
            height: 3rem;
            border: 1px solid #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
        }

/* .cell {
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-weight: bold;
    flex: 1 1 auto;
} */

        .cell.revealed {
            background-color: #f0f0f0;
        }
        .cell.flag {
            background-color: #ffaaaa;
        }
        .cell.mine {
            /* background-color: #ff4444; */
        }
        .cell.number {
            color: #333;
        }
        .cell.flagged {
            color: #000;
        }

		.ignoremouse {
			pointer-events: none;
			user-select: none;
		}
    </style>
</head>
<body>
    <div class="container mt-5">
        <h2 class="text-center">Minesweeper</h2>
        <div id="app">
            <div class="d-flex justify-content-center mb-3">
                <button @click="restartGame" class="btn btn-primary">Restart</button>
            </div>
            <!-- <div class="d-flex flex-wrap"> -->
                <div 
                    v-for="(row, rowIndex) in grid" 
                    :key="rowIndex" 
                    class="d-flex"
                >
                    <div 
                        v-for="(cell, cellIndex) in row" 
                        :key="cellIndex"
                        class="cell"
                        :class="{
                            'revealed': cell.revealed,
                            'flag': cell.flag,
                            'mine': cell.mine,
                            'number': cell.number
                        }"
                        @click="leftClick(rowIndex, cellIndex)"
						@mousedown="console.log('mousedown on', rowIndex, cellIndex)"
						@mouseup="console.log('mouseup on', rowIndex, cellIndex)"
                        @contextmenu.prevent="toggleFlag(rowIndex, cellIndex)"
                    >
						<div class="ignoremouse" :style="{
							color: numberColor[cell.number]
						}">
							{{ getIcon(cell, rowIndex, cellIndex) }}
						</div>
                    </div>
                </div>
            <!-- </div> -->
        </div>
    </div>

    <!-- Vue and Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                rows: 11,
                cols: 11,
                mines: 15,
                grid: [],
                gameStarted: false,
                gameOver: false,
				clickable: false,
				numberColor: ["#000000", "#66a4dd", "#50a050", "#c67", "#b7d", "#a90", "#5aa", "#999", "#ccc"]
            },
            mounted() {
                this.restartGame();
            },
            methods: {
				getIcon(cell, r, c) {
					// if (r==this.rows>>1 && c==this.cols>>1) {
					// 	return cell.flag ? 'ðŸš©' : cell.revealed ? cell.mine ? 'ðŸ’£' : cell.number?cell.number:'' : 'x'
					// }
					return cell.flag ? 'ðŸš©' : cell.revealed ? cell.mine ? 'ðŸ’£' : cell.number?cell.number:'' : ''
				},
				// getNumberColor(number) {

				// },
                restartGame() {
                    this.gameOver = false;
                    this.gameStarted = true;
                    this.grid = this.generateGrid();
					this.clickable = true;
                },
                generateGrid() {
                    const grid = Array(this.rows).fill().map(() => 
                        Array(this.cols).fill().map(() => ({
                            revealed: false,
                            flag: false,
                            mine: false,
                            number: 0
                        }))
                    );

                    // Place mines
                    let minesPlaced = 0;
                    while (minesPlaced < this.mines) {
                        const row = Math.floor(Math.random() * this.rows);
                        const col = Math.floor(Math.random() * this.cols);
                        if (!grid[row][col].mine) {
                            grid[row][col].mine = true;
                            minesPlaced++;
                        }
                    }

                    // Calculate numbers
                    for (let row = 0; row < this.rows; row++) {
                        for (let col = 0; col < this.cols; col++) {
                            if (!grid[row][col].mine) {
                                let count = 0;
                                for (let i = -1; i <= 1; i++) {
                                    for (let j = -1; j <= 1; j++) {
                                        const r = row + i;
                                        const c = col + j;
                                        if (r >= 0 && r < this.rows && c >= 0 && c < this.cols) {
                                            if (grid[r][c].mine) count++;
                                        }
                                    }
                                }
                                grid[row][col].number = count;
                            }
                        }
                    }

                    return grid;
                },
                leftClick(row, col) {
                    if (this.gameOver || this.grid[row][col].flag) return;

                    const cell = this.grid[row][col];
                    if (cell.mine) {
                        this.gameOver = true;
                        this.revealAllMines();
                        return;
                    }
					
					if (cell.revealed) {
						this.chord(row, col);
						return;
					}

                    cell.revealed = true;

                    if (cell.number === 0) {
                        for (let i = -1; i <= 1; i++) {
                            for (let j = -1; j <= 1; j++) {
                                const r = row + i;
                                const c = col + j;
                                if (r >= 0 && r < this.rows && c >= 0 && c < this.cols) {
                                    // this.leftClick(r, c);
									this.floodOpen([[r, c]])
                                }
                            }
                        }
                    }

                    this.checkWin();
                },
				delay(ms) {
					return new Promise(res => setTimeout(res, ms))
				},
				// starting: array of [[row1, col1], [row2, col2], ...]
				async floodOpen(cur) {
					this.clickable = false;

					for (const coords of cur) {
						const r = coords[0];
						const c = coords[1];

						this.grid[r][c].revealed = true;
					}

					for (const coords of cur) {
						const r = coords[0];
						const c = coords[1];
						if (this.grid[r][c].mine) {
							this.gameOver = true;
							this.revealAllMines();
							return
						}
					}

					const dir = [1,0,-1,0,1];
					while (cur.length>0) {
						await this.delay(70)
						let nxt = [];
						for (const coords of cur) {
							const r = coords[0];
							const c = coords[1];
							if (this.grid[r][c].number>0) continue;

							// for (let i=0; i<4; i++) {
							// 	const dr = dir[i], dc = dir[i+1];
							for (let dr=-1; dr<=1; dr++) {
								for (let dc=-1; dc<=1; dc++) {
									const nr = r+dr, nc = c+dc;

									// Bounds
									if (nr < 0 || nr >= this.rows || nc < 0 || nc >= this.cols) continue;
									const cell = this.grid[nr][nc]
									
									// 
									if (cell.revealed) continue;
									cell.revealed = true

									if (cell.number==0) {
										nxt.push([nr, nc])
									}
										
								}
							}
						}

						cur = nxt;
					}

					this.clickable = true;

					this.checkWin()
				},
				chord(row, col) {
					let flagCount = 0;

					// console.log("Chord on", row, col, this.grid[row][col])

                    // Check the 3x3 area around the clicked cell
                    for (let i = -1; i <= 1; i++) {
                        for (let j = -1; j <= 1; j++) {
                            const r = row + i;
                            const c = col + j;

							if (r >= 0 && r < this.rows && c >= 0 && c < this.cols && this.grid[r][c].flag)
								flagCount++;
						}
					}
					// console.log(this.grid[row][col].number, flagCount)

					if (this.grid[row][col].number != flagCount) return;

					let toClick = [];
					for (let i = -1; i <= 1; i++) {
                        for (let j = -1; j <= 1; j++) {
                            const r = row + i;
                            const c = col + j;

							if (r >= 0 && r < this.rows && c >= 0 && c < this.cols) {
								if (this.grid[r][c].flag) continue;
								if (this.grid[r][c].revealed) continue;
								toClick.push([r, c])
							}
								
						}
					}

					// console.log(toClick)

					this.floodOpen(toClick);
				
				},
                revealAllMines() {
                    for (let row = 0; row < this.rows; row++) {
                        for (let col = 0; col < this.cols; col++) {
                            if (this.grid[row][col].mine) {
                                this.grid[row][col].revealed = true;
                                this.grid[row][col].mine = true; // Ensure mine is visible
                            }
                        }
                    }
                },
                toggleFlag(row, col) {
                    if (this.gameStarted && !this.grid[row][col].revealed) {
                        this.grid[row][col].flag = !this.grid[row][col].flag;
                        this.checkWin();
                    }
                },
                checkWin() {
                    let revealed = 0;
                    let flagged = 0;

                    for (let row = 0; row < this.rows; row++) {
                        for (let col = 0; col < this.cols; col++) {
                            const cell = this.grid[row][col];
                            if (cell.revealed && !cell.mine) revealed++;
                            if (cell.flag && cell.mine) flagged++;
                        }
                    }

					if (revealed === this.rows * this.cols - this.mines) {
                        this.gameOver = true;
                        console.log('Congratulations! You won!');
                    }

                    // if (revealed + flagged === this.mines + (this.rows * this.cols - this.mines)) {
                    //     this.gameOver = true;
                    //     alert('Congratulations! You won!');
                    // }
                }
            }
        });
    </script>
</body>
</html>
